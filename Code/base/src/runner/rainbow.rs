//! # Rainbow

use super::*;

use crate::util::rgb::RGB;
use std::time::Duration;

/// Struct for animating the classic RGB rainbow puke that we all know and love
/// but instead of displaying on a fancy RGB keyboard it's just these stupid
/// LEDs puking out everything.
pub struct Rainbow {
    hue: f32,
    saturation: f32,
    value: f32,
    dh: f32,

    arc: f32,
    step: usize,
}

impl Rainbow {
    /// Creates a new `Rainbow` object.
    /// 
    /// # Parameters
    /// 
    /// * `rainbow_length` - The length of time it takes for the rainbow to fully cycle through all the LEDs.
    /// * `saturation` - The saturation to be used for all colors generated by HSV values.
    /// * `value` - The value to be used for all colors generated by HSV values.
    /// * `arc` - The amount of the arc between hue 0 and 360 (mapped to the range [0, 1] for this parameter) that is displayed across all the LEDs. NOTE: The arc can be larger than one, and can be as large as you like. For example an arc value of 2 would mean that there are 2 full rainbows visible across the LEDs.
    /// * `step` - The number of LEDs in a row that keep the same color before moving on to the next color. E.g if a step of 1 yields an LED array of \[1, 2, 3, 4\], then a step of 2 yields an array of \[1, 1, 2, 2\].
    pub fn new(rainbow_length: Duration, saturation: f32, value: f32, arc: f32, step: usize) -> Self {
        Self {
            hue: 0.0,
            saturation,
            value,
            dh: 360.0 / rainbow_length.as_secs_f32(),

            arc,
            step,
        }
    }
}

impl Animation for Rainbow {
    fn update(&mut self, dt: Duration, frame: &mut [RGB]) {
        self.hue += self.dh * dt.as_secs_f32();

        if self.hue >= 360.0 {
            self.hue -= 360.0;
        }

        let len = frame.len() as f32;
        for (i, led) in frame.iter_mut().enumerate() {
            let step = i as f32 / self.step as f32;
            let step = step.floor();
            let step = step * (self.step as f32);
            let step = step / len;
            let step = step * 360.0 * self.arc;
            *led = RGB::from_hsv(self.hue + step, self.saturation, self.value);
        }
    }
}
